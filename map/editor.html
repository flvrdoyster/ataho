<html>

<head>
    <style>
        body {
            background: #222;
            display: flex;
            flex-direction: row;
            font-family: sans-serif;
            height: 100vh;
            margin: 0;
            overflow: hidden;
        }

        .editor-container {
            flex: 1;
            overflow: auto;
            background: #333;
            position: relative;
            display: flex;
            justify-content: flex-start;
            align-items: flex-start;
            padding: 20px;
        }

        .map-grid {
            position: relative;
            background: #000;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
        }

        .tile {
            position: absolute;
            width: 16px;
            height: 16px;
            /* pointer-events: none; REMOVED to allow simple clicks, but we handle click on map container usually? 
               Actually tile has onclick. Keep it. */
            cursor: pointer;
            image-rendering: pixelated;
            background-image: url('assets/cave/cave_tile.png');
            background-repeat: no-repeat;
            z-index: 1;
        }

        .anim-obj {
            position: absolute;
            background-repeat: no-repeat;
            image-rendering: pixelated;
            z-index: 10;
            /* Above tiles */
            border: 1px solid rgba(255, 255, 0, 0.5);
            /* Highlight bounds */
            pointer-events: none;
            /* Let clicks pass to grid? No, we might want to select/delete. */
            cursor: pointer;
        }

        .anim-obj:hover {
            border: 1px solid yellow;
        }

        .collision-overlay {
            position: absolute;
            background: rgba(255, 0, 0, 0.5);
            z-index: 15;
            pointer-events: none;
            cursor: pointer;
            width: 16px;
            height: 16px;
        }

        .reference-overlay {
            position: absolute;
            top: 0;
            left: 0;
            /* transform: translateY(-50%); REMOVED */
            z-index: 2;
            opacity: 0.5;
            pointer-events: none;
            opacity: 0.5;
            pointer-events: none;
            width: 610px;
            height: auto;
            max-width: none;
            margin-left: -8px;
            margin-top: 15px;
        }

        .tile:hover {
            z-index: 100;
            outline: 1px solid white;
        }

        .tile.empty {
            background: none !important;
        }

        .sidebar {
            width: 600px;
            background: #1a1a1a;
            color: #eee;
            padding: 20px;
            display: flex;
            flex-direction: column;
            border-right: 1px solid #444;
            z-index: 200;
        }

        .palette {
            display: grid;
            grid-template-columns: repeat(16, 32px);
            background: #000;
            padding: 5px;
            /* max-height removed to show all tiles */
            /* overflow-y removed */
            border: 1px solid #555;
        }

        .palette-tile {
            width: 32px;
            height: 32px;
            margin: 0;
            cursor: pointer;
            border: 2px solid transparent;
            box-sizing: border-box;
            image-rendering: pixelated;
            background-image: url('assets/cave/cave_tile.png');
            background-size: 512px auto;
            /* Scale up for palette visibility (32px view of 16px tile) -> 16px * 2 = 32px, so total width * 2 */
            background-repeat: no-repeat;
        }

        .palette-tile.selected {
            border: 2px solid cyan;
            z-index: 10;
        }

        .palette-tile:hover {
            border-color: #888;
        }

        .controls {
            margin-top: 20px;
        }

        button {
            padding: 10px;
            width: 100%;
            margin-bottom: 10px;
            background: #444;
            color: white;
            border: none;
            cursor: pointer;
        }

        button:hover {
            background: #555;
        }

        button.active {
            background: #d32f2f;
            font-weight: bold;
        }

        textarea {
            width: 100%;
            height: 100px;
            background: #222;
            color: #aaa;
            border: 1px solid #444;
            margin-top: 10px;
            font-size: 10px;
        }
    </style>
</head>

<body>
    <div class="sidebar">
        <h2>Map Editor</h2>
        <div class="palette" id="palette"></div>
        <div class="controls">
            <p>Selected Tile: <span id="selected-id">None</span></p>
            <p>Hover: <span id="hover-coords">--,--</span></p>

            <div style="margin-bottom: 10px; border-bottom: 1px solid #555; padding-bottom: 10px;">
                <label><input type="radio" name="mode" value="tile" checked onchange="setMode('tile')"> Tile
                    Mode</label>
                <label><input type="radio" name="mode" value="anim" onchange="setMode('anim')"> Animation Mode</label>
            </div>

            <!-- Animation Palette (Hidden by default) -->
            <div id="anim-palette" style="display:none; margin-bottom: 15px;">
                <h3>Animations</h3>
                <div class="anim-item" onclick="selectAnim('irori')"
                    style="cursor: pointer; border: 1px solid #444; padding: 5px; margin-bottom: 5px;">
                    Irori (Hearth)
                </div>
            </div>

            <div style="margin-bottom: 10px; display: flex; gap: 5px;">
                <button onclick="setEraser()" style="flex: 1; background: #c33;">Eraser</button>
            </div>
            <div style="margin-bottom: 10px; display: flex; gap: 5px;">
                <button onclick="changeZoom(0.1)" style="flex: 1;">Zoom +</button>
                <button onclick="changeZoom(-0.1)" style="flex: 1;">Zoom -</button>
                <button onclick="resetZoom()" style="flex: 1;">Reset</button>
            </div>
            <p>Zoom: <span id="zoom-level">100%</span></p>
            <div style="margin-bottom: 10px; margin-top: 10px;">
                <button onclick="toggleOverlay()">Toggle Overlay</button>
            </div>
            <div style="margin-bottom: 10px;">
                <label for="overlay-width">Overlay Width:</label>
                <input type="number" id="overlay-width" value="610" onchange="updateOverlayWidth(this.value)"
                    style="width: 60px;"> px
            </div>
            <div style="margin-bottom: 10px;">
                <label for="overlay-offset-x">Overlay X Offset:</label>
                <input type="number" id="overlay-offset-x" value="-8" onchange="updateOverlayOffsetX(this.value)"
                    style="width: 60px;"> px
            </div>
            <div style="margin-bottom: 10px;">
                <label for="overlay-offset-y">Overlay Y Offset:</label>
                <input type="number" id="overlay-offset-y" value="15" onchange="updateOverlayOffsetY(this.value)"
                    style="width: 60px;"> px
            </div>
            <div style="margin-bottom: 10px;">
                <button id="collisionBtn" onclick="toggleCollisionMode()">Collision Mode: OFF</button>
            </div>
            <button onclick="exportData()">Export JSON</button>
            <textarea id="output" readonly></textarea>
        </div>
    </div>
    <div class="editor-container">
        <div class="map-grid" id="map"></div>
    </div>

    <!-- External Data -->
    <script src="data/map_data.js"></script>

    <script>
        // Configuration
        const TILE_SIZE = 16;
        const PALETTE_SCALE = 2; // Show tiles 2x bigger in palette
        const ASSET_PATH = 'assets/cave/cave_tile.png';
        const EMPTY_TILE = { tx: 1, ty: 0 };

        let currentMode = 'tile'; // 'tile' or 'anim'
        let selectedAnimType = null;

        let animations = []; // Array of { type, x, y }
        let isCollisionMode = false;
        let collisionTiles = new Set(); // Stores "gx,gy" strings

        let selectedTx = 0;
        let selectedTy = 0;
        let tilesetWidth = 0;
        let tilesetHeight = 0;
        let zoomLevel = 1.0;

        // Initialize
        const img = new Image();
        img.src = ASSET_PATH;
        img.onload = function () {
            tilesetWidth = img.width;
            tilesetHeight = img.height;
            initEditor();
        };
        img.onerror = function () {
            alert("Failed to load tileset image: " + ASSET_PATH);
        }

        function initEditor() {
            console.log("Initializing Editor...");

            // 1. Build Palette
            const cols = Math.floor(tilesetWidth / TILE_SIZE);
            const rows = Math.floor(tilesetHeight / TILE_SIZE);
            const palette = document.getElementById('palette');

            // Adjust background size for palette scaling
            // Original width is tilesetWidth. We want 16px tile to be 32px.
            // So we scale the background by PALETTE_SCALE.
            const bgWidth = tilesetWidth * PALETTE_SCALE;

            // Update CSS rule dynamically for palette scale or just set inline

            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    let d = document.createElement('div');
                    d.className = 'palette-tile';
                    // We need to set background position.
                    // Since background-size is 200% (roughly), position needs to be scaled too?
                    // No, background-position is in pixels related to the element box or percentage.
                    // If we set background-size to specific px, we use specific px for position.
                    d.style.backgroundSize = `${bgWidth}px auto`;
                    d.style.backgroundPosition = `-${x * TILE_SIZE * PALETTE_SCALE}px -${y * TILE_SIZE * PALETTE_SCALE}px`;

                    d.onclick = function () { selectTile(this, x, y); };
                    palette.appendChild(d);
                }
            }

            // 2. Load Map Data
            const mapContainer = document.getElementById('map');
            mapContainer.innerHTML = '';

            // Add reference overlay
            const overlay = document.createElement('img');
            overlay.src = 'assets/cave/cave_ori.png';
            overlay.className = 'reference-overlay';
            overlay.onload = function () {
                const currentW = parseInt(mapContainer.style.width) || 0;
                const currentH = parseInt(mapContainer.style.height) || 0;
                // Use rendered width/height (overlay.width/height) instead of naturalWidth/Height
                updateMapSizeForOverlay();
            };
            mapContainer.appendChild(overlay);

            let tilesToRender = [];
            if (window.MAP_DATA) {
                // Check if old format (Array) or new format (Object)
                if (Array.isArray(window.MAP_DATA)) {
                    console.log("Loading legacy map data (Array)");
                    tilesToRender = window.MAP_DATA;
                } else {
                    console.log("Loading map data (Object)");
                    tilesToRender = window.MAP_DATA.tiles || [];
                    animations = window.MAP_DATA.animations || [];
                    renderAnimations();
                    if (window.MAP_DATA.collisions) {
                        window.MAP_DATA.collisions.forEach(c => collisionTiles.add(`${c.x},${c.y}`));
                    }
                    renderCollisions();
                }
            } else {
                console.warn("No MAP_DATA found, starting empty.");
            }

            let maxX = 0;
            let maxY = 0;

            tilesToRender.forEach(tileData => {
                let div = document.createElement('div');
                div.className = 'tile';
                div.id = `cell_${tileData.gx}_${tileData.gy}`;
                div.style.left = (tileData.gx * TILE_SIZE) + 'px';
                div.style.top = (tileData.gy * TILE_SIZE) + 'px';
                div.dataset.tx = tileData.tx;
                div.dataset.ty = tileData.ty;

                // Set background position for map tile (1x scale)
                if (tileData.tx === EMPTY_TILE.tx && tileData.ty === EMPTY_TILE.ty) {
                    div.classList.add('empty');
                } else {
                    div.style.backgroundPosition = `-${tileData.tx * TILE_SIZE}px -${tileData.ty * TILE_SIZE}px`;
                }

                div.onclick = function () { onGridClick(this, tileData.gx, tileData.gy); };
                div.onmousemove = function () {
                    document.getElementById('hover-coords').innerText = tileData.gx + "," + tileData.gy;
                };
                mapContainer.appendChild(div);

                if (tileData.gx > maxX) maxX = tileData.gx;
                if (tileData.gy > maxY) maxY = tileData.gy;
            });

            mapContainer.style.width = ((maxX + 1) * TILE_SIZE) + 'px';
            mapContainer.style.height = ((maxY + 1) * TILE_SIZE) + 'px';
        }

        function selectTile(el, tx, ty) {
            setMode('tile'); // Auto switch
            document.querySelectorAll('.palette-tile').forEach(t => t.classList.remove('selected'));
            el.classList.add('selected');
            selectedTx = tx;
            selectedTy = ty;
            document.getElementById('selected-id').innerText = tx + "," + ty;
        }

        function setMode(mode) {
            currentMode = mode;
            document.getElementById('palette').style.display = (mode === 'tile') ? 'grid' : 'none';
            document.getElementById('anim-palette').style.display = (mode === 'anim') ? 'block' : 'none';

            // UI Update
            document.querySelectorAll('input[name="mode"]').forEach(r => {
                if (r.value === mode) r.checked = true;
            });
        }

        function selectAnim(type) {
            selectedAnimType = type;
            document.getElementById('selected-id').innerText = "Anim: " + type;
        }

        function onGridClick(el, gx, gy) {
            if (isCollisionMode) {
                toggleCollisionAt(gx, gy);
            } else if (currentMode === 'tile') {
                paintTile(el, gx, gy);
            } else if (currentMode === 'anim') {
                placeAnimation(gx, gy);
            }
        }

        function placeAnimation(gx, gy) {
            if (!selectedAnimType) {
                alert("Select an animation first!");
                return;
            }

            // Add new animation
            // Irori config: 5 frames, 64x48.
            // Helper to get config based on type
            let config = { type: 'irori', w: 64, h: 48 }; // Corrected to 4 tiles wide

            // Center logic? Or Top-Left?
            // User clicks a tile. Let's place Top-Left at that tile?
            // Or center?
            // Let's assume user clicks the Top-Left tile of the desired position.
            // gx, gy -> pixels

            let anim = {
                type: selectedAnimType,
                x: gx * TILE_SIZE,
                y: gy * TILE_SIZE,
                w: 64,
                h: 48
            };

            animations.push(anim);
            renderAnimations();
        }

        function renderAnimations() {
            // Clear existing anim divs?
            document.querySelectorAll('.anim-obj').forEach(e => e.remove());

            const mapContainer = document.getElementById('map');

            animations.forEach((anim, index) => {
                const div = document.createElement('div');
                div.className = 'anim-obj';
                div.style.left = anim.x + 'px';
                div.style.top = anim.y + 'px';
                div.style.width = anim.w + 'px';
                div.style.height = anim.h + 'px';
                div.dataset.type = anim.type; // Store type for animator

                // Show first frame
                if (anim.type === 'irori') {
                    div.style.backgroundImage = "url('assets/cave/cave_tile_irori.png')";
                    div.style.backgroundPosition = "0 0";
                }

                // Delete on right click? or click in delete mode?
                div.onclick = (e) => {
                    e.stopPropagation(); // Prevent grid click
                    if (confirm("Delete this animation?")) {
                        animations.splice(index, 1);
                        renderAnimations();
                    }
                };

                mapContainer.appendChild(div);
            });
        }

        function toggleCollisionMode() {
            isCollisionMode = !isCollisionMode;
            const btn = document.getElementById('collisionBtn');
            if (isCollisionMode) {
                btn.innerText = "Collision Mode: ON";
                btn.classList.add('active');
            } else {
                btn.innerText = "Collision Mode: OFF";
                btn.classList.remove('active');
            }
            renderCollisions();
        }

        function toggleCollisionAt(gx, gy) {
            const key = `${gx},${gy}`;
            if (collisionTiles.has(key)) {
                collisionTiles.delete(key);
            } else {
                collisionTiles.add(key);
            }
            renderCollisions();
        }

        function renderCollisions() {
            // Clear existing
            document.querySelectorAll('.collision-overlay').forEach(e => e.remove());

            if (!isCollisionMode && collisionTiles.size === 0) return;
            // Even if not in mode, we might want to see them? Or only in mode?
            // Let's show them if in mode OR we can just show them always? 
            // Usually editor shows walls always or in a view mode. 
            // For now, show if isCollisionMode is true? 
            // Or maybe always show semi-transparent if they exist?
            // Let's show always for now if the user toggled them on? 
            // Actually, let's just render them. 

            // Wait, the Requirement was "Visual Feedback: Render placed animations on the map editor grid."
            // For collisions: "When Collision Mode is active, render a semi-transparent red overlay"

            if (!isCollisionMode) return;

            const mapContainer = document.getElementById('map');
            collisionTiles.forEach(key => {
                const [gx, gy] = key.split(',').map(Number);
                const div = document.createElement('div');
                div.className = 'collision-overlay';
                div.style.left = (gx * TILE_SIZE) + 'px';
                div.style.top = (gy * TILE_SIZE) + 'px';
                div.onclick = (e) => {
                    e.stopPropagation(); // Pass through to grid? 
                    // No, invalidates click if we catch it. 
                    // But we want to toggle.
                    if (isCollisionMode) toggleCollisionAt(gx, gy);
                };
                mapContainer.appendChild(div);
            });
        }

        // Editor Animation Loop
        function startEditorLoop() {
            const startTime = Date.now();

            function loop() {
                const now = Date.now();

                document.querySelectorAll('.anim-obj').forEach(div => {
                    const type = div.dataset.type;
                    if (type === 'irori') {
                        // 5 frames, 200ms each (Slower)
                        const frames = 5;
                        const speed = 200;
                        const width = 64;

                        const frameIndex = Math.floor(now / speed) % frames;
                        div.style.backgroundPosition = `-${frameIndex * width}px 0px`;
                    }
                });

                requestAnimationFrame(loop);
            }
            requestAnimationFrame(loop);
        }

        // Start immediately
        startEditorLoop();

        function setEraser() {
            document.querySelectorAll('.palette-tile').forEach(t => t.classList.remove('selected'));
            selectedTx = EMPTY_TILE.tx;
            selectedTy = EMPTY_TILE.ty;
            document.getElementById('selected-id').innerText = "Eraser";
        }

        function changeZoom(delta) {
            zoomLevel += delta;
            if (zoomLevel < 0.1) zoomLevel = 0.1;
            updateZoom();
        }

        function resetZoom() {
            zoomLevel = 1.0;
            updateZoom();
        }

        function updateZoom() {
            const mapGrid = document.getElementById('map');
            // Use transform-origin top-left to zoom naturally from the corner
            mapGrid.style.transformOrigin = "0 0";
            mapGrid.style.transform = `scale(${zoomLevel})`;
            document.getElementById('zoom-level').innerText = Math.round(zoomLevel * 100) + "%";
        }

        function updateOverlayOffsetX(val) {
            const overlay = document.querySelector('.reference-overlay');
            if (overlay) {
                overlay.style.marginLeft = val + 'px';
            }
        }

        function updateOverlayOffsetY(val) {
            const overlay = document.querySelector('.reference-overlay');
            if (overlay) {
                overlay.style.marginTop = val + 'px';
            }
        }

        function updateOverlayWidth(val) {
            const overlay = document.querySelector('.reference-overlay');
            if (overlay) {
                overlay.style.width = val + 'px';
                // Wait for layout update before resizing map
                setTimeout(updateMapSizeForOverlay, 50);
            }
        }

        function toggleOverlay() {
            const overlay = document.querySelector('.reference-overlay');
            if (overlay) {
                overlay.style.display = (overlay.style.display === 'none') ? 'block' : 'none';
            }
        }

        function updateMapSizeForOverlay() {
            const overlay = document.querySelector('.reference-overlay');
            const mapContainer = document.getElementById('map');
            if (!overlay || !mapContainer) return;

            const currentW = parseInt(mapContainer.style.width) || 0;
            const currentH = parseInt(mapContainer.style.height) || 0;

            if (overlay.width > currentW) mapContainer.style.width = overlay.width + 'px';
            if (overlay.height > currentH) mapContainer.style.height = overlay.height + 'px';
        }

        function paintTile(el, gx, gy) {
            // Update visual
            if (selectedTx === EMPTY_TILE.tx && selectedTy === EMPTY_TILE.ty) {
                el.classList.add('empty');
                el.style.backgroundPosition = '';
            } else {
                el.classList.remove('empty');
                el.style.backgroundPosition = `-${selectedTx * TILE_SIZE}px -${selectedTy * TILE_SIZE}px`;
            }
            // Update data
            el.dataset.tx = selectedTx;
            el.dataset.ty = selectedTy;
        }

        function exportData() {
            let cells = document.querySelectorAll('.tile');
            let data = [];
            cells.forEach(c => {
                let parts = c.id.split('_');
                let gx = parseInt(parts[1]);
                let gy = parseInt(parts[2]);
                let tx = parseInt(c.dataset.tx);
                let ty = parseInt(c.dataset.ty);
                data.push({ gx, gy, tx, ty });
            });

            const exportData = {
                tiles: data,
                animations: animations,
                collisions: Array.from(collisionTiles).map(k => {
                    const [x, y] = k.split(',').map(Number);
                    return { x, y };
                })
            };

            document.getElementById('output').value = "window.MAP_DATA = " + JSON.stringify(exportData);
        }
    </script>
</body>

</html>