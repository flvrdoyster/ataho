const BLINK_BASE_SEQ = [1, 0, 1];

class PortraitCharacter {
    constructor(characterData, config, isCpu = false) {
        this.data = characterData;
        this.config = config; // { x, y, w, h, baseW, baseH }
        this.isCpu = isCpu;

        this.animConfig = null;

        // Animation State
        this.state = 'idle'; // idle, talk...
        this.blinkTimer = 0;
        this.blinkSequence = [];
        this.blinkFrameIndex = -1; // -1 means not blinking
        this.currentBlinkFrame = null;

        // Talk State
        this.isTalking = false;
        this.talkTimer = 0;
        this.talkSequence = []; // e.g. [0, 1, 2, 1]
        this.talkFrameIndex = 0;
        this.currentTalkFrame = null;

        // Cache
        this.renderRect = { x: 0, y: 0, w: 0, h: 0 };
        this._sheetCache = new Map(); // Cache sheet status by Image object
        this._dirty = true; // Dirty flag for recalculating rects
    }

    get id() {
        return this.data ? this.data.id : null;
    }

    // Optimization: Reuse instance to reduce GC
    updateCharacter(characterData) {
        if (this.data === characterData) return;
        this.data = characterData;

        // Reset State
        this.state = 'idle';
        this.blinkTimer = 0;
        this.blinkFrameIndex = -1;
        this.currentBlinkFrame = null;
        this.isTalking = false;
        this.currentTalkFrame = null;
        this.talkSequence = []; // Will be regenerated by setAnimationConfig if needed? No, startTalk.

        // Note: animConfig must be updated separately via setAnimationConfig
        this.animConfig = null;
        this._dirty = true; // Mark dirty on data change
    }

    setAnimationConfig(config) {
        this.animConfig = config;
        if (!this.animConfig) return;

        // --- OPTIMIZATION: Defaults & Auto-Generation ---

        // 1. Scalar Defaults
        if (!this.animConfig.interval) this.animConfig.interval = 80;
        if (!this.animConfig.speed) this.animConfig.speed = 3;
        if (!this.animConfig.talkSpeed) this.animConfig.talkSpeed = 4;

        // 2. Asset Auto-Generation
        if (this.animConfig.base) {
            const base = this.animConfig.base;
            const prefix = base.replace('_base.png', '');

            // Auto-generate Blink
            if (!this.animConfig.blink) {
                const detectedBlinks = [];
                for (let i = 1; i <= 5; i++) {
                    const key = `${prefix}_blink-${i}.png`;
                    if (Assets.get(key)) detectedBlinks.push(key);
                    else break;
                }
                if (detectedBlinks.length > 0) this.animConfig.blink = detectedBlinks;
            }

            // Auto-generate Talk
            if (!this.animConfig.talk) {
                const detectedTalks = [this.animConfig.base];
                for (let i = 1; i <= 5; i++) {
                    const key = `${prefix}_talk-${i}.png`;
                    if (Assets.get(key)) detectedTalks.push(key);
                    else break;
                }

                if (detectedTalks.length > 1) {
                    this.animConfig.talk = detectedTalks;
                    // Auto-Default Sequence
                    if (detectedTalks.length === 3 && !this.animConfig.talkSequence) {
                        this.animConfig.talkSequence = [0, 2, 1, 2];
                    }
                }
            }

            // Auto-generate Expressions
            if (!this.animConfig.smile && Assets.get(`${prefix}_smile.png`)) {
                this.animConfig.smile = `${prefix}_smile.png`;
            }
            if (!this.animConfig.shocked && Assets.get(`${prefix}_shocked.png`)) {
                this.animConfig.shocked = `${prefix}_shocked.png`;
            }
            if (!this.animConfig.idle && Assets.get(`${prefix}_idle.png`)) {
                this.animConfig.idle = `${prefix}_idle.png`;
            }
        }

        this.blinkTimer = Math.floor(Math.random() * this.animConfig.interval);
        this._dirty = true; // Mark dirty on config change
    }

    setState(newState) {
        this.state = newState;
    }

    setTalking(talking) {
        if (this.isTalking === talking) return;
        this.isTalking = talking;

        if (talking) {
            if (!this.startTalk()) this.isTalking = false;
        } else {
            this.currentTalkFrame = null;
        }
    }

    startTalk() {
        if (!this.animConfig?.talk?.length) return false;

        if (!this.talkSequence || this.talkSequence.length === 0) {
            if (this.animConfig.talkSequence) {
                this.talkSequence = this.animConfig.talkSequence;
            } else if (this.animConfig.talk.length === 3) {
                this.talkSequence = [0, 2, 1, 2];
            } else if (this.animConfig.talk.length === 2) {
                this.talkSequence = [0, 1, 0, 1];
            } else {
                this.talkSequence = [0, 1];
            }
        }

        this.talkFrameIndex = 0;
        this.updateTalkFrame();
        this.talkTimer = this.animConfig.talkSpeed || 5;
        return true;
    }

    update() {
        if (!this.animConfig) return;

        // Blink Logic
        this.blinkTimer--;
        if (this.blinkTimer <= 0) {
            if (this.blinkFrameIndex === -1) {
                this.startBlink();
            } else {
                this.advanceBlink();
            }
        }

        // Talk Logic
        if (this.isTalking) {
            if (this.animConfig.talk?.length > 0) {
                this.talkTimer--;
                if (this.talkTimer <= 0) this.advanceTalk();
            } else {
                this.isTalking = false;
            }
        }
    }

    advanceTalk() {
        if (!this.talkSequence?.length) return;
        this.talkFrameIndex = (this.talkFrameIndex + 1) % this.talkSequence.length;
        this.updateTalkFrame();
        this.talkTimer = this.animConfig.talkSpeed || 5;
    }

    updateTalkFrame() {
        const frameIdx = this.talkSequence[this.talkFrameIndex];
        // Direct access is faster than bounds check slightly if data is trusted, but keeping safety
        this.currentTalkFrame = (frameIdx < this.animConfig.talk.length) ? this.animConfig.talk[frameIdx] : null;
    }

    startBlink() {
        if (!this.animConfig?.blink?.length) return;

        const isDouble = Math.random() < 0.35;

        if (isDouble) {
            // Re-use array if possible or just create new one. Spreading is okay here.
            // OPTIMIZATION: Recycle array if needed, but for now simple spread is OK.
            // Better: modify in place if this.blinkSequence is reused?
            this.blinkSequence = [...BLINK_BASE_SEQ, -1, -1, ...BLINK_BASE_SEQ];
        } else {
            this.blinkSequence = BLINK_BASE_SEQ;
        }

        this.blinkFrameIndex = 0;
        this.updateBlinkFrame();
        this.blinkTimer = this.animConfig.speed || 4;
    }

    advanceBlink() {
        this.blinkFrameIndex++;
        if (this.blinkFrameIndex >= this.blinkSequence.length) {
            this.blinkFrameIndex = -1;
            this.currentBlinkFrame = null;
            this.blinkTimer = this.animConfig.interval || 80;
        } else {
            this.updateBlinkFrame();
            this.blinkTimer = this.animConfig.speed || 4;
        }
    }

    updateBlinkFrame() {
        const frameIdx = this.blinkSequence[this.blinkFrameIndex];
        this.currentBlinkFrame = (frameIdx >= 0 && frameIdx < this.animConfig.blink.length)
            ? this.animConfig.blink[frameIdx]
            : null;
    }

    // --- RENDER LOGIC ---

    _updateRenderRect(baseImg) {
        const scale = this.config.scale || 1.0;
        const globalBaseW = BattleConfig.PORTRAIT.baseW || 264;

        // 1. Determine Frame Width (Auto-Slice logic embedded here to avoid double lookup)
        // 1. Determine Frame Width (Auto-Slice logic embedded here to avoid double lookup)
        // Check cache
        if (!this._sheetCache.has(baseImg)) {
            // Cache logic
            if (baseImg.width > 0) {
                this._sheetCache.set(baseImg, (baseImg.width >= globalBaseW * 1.5));
            }
        }
        const isSheet = !!this._sheetCache.get(baseImg);

        const frameW = isSheet ? (baseImg.width / 2) : baseImg.width;
        const frameH = baseImg.height;

        // 2. Calculate Dims
        const destW = frameW * scale;
        const destH = frameH * scale;

        // 3. Calculate Position
        let dx = Math.floor(this.config.x);
        let dy = Math.floor(this.config.y);

        if (this.config.align === 'right') {
            dx -= destW;
        }

        // 4. Apply Offsets
        if (this.animConfig) {
            dx += (this.animConfig.xOffset || 0);
            dy += (this.animConfig.yOffset || 0);
        }

        // Character Data Offsets
        if (this.config.isBattle) {
            dx += (this.data.battleOffsetX || 0);
            dy += (this.data.battleOffsetY || 0);
        }
        if (this.isCpu) {
            dx += (this.data.cpuOffsetX || 0);
        }

        // Store
        this.renderRect.x = dx;
        this.renderRect.y = dy;
        this.renderRect.w = destW;
        this.renderRect.h = destH;
        this.renderRect.isSheet = isSheet; // Store sheet status for overlay use

        this._dirty = false; // Clear dirty flag
    }

    draw(ctx) {
        if (!this.data) return;

        // A. Animation Config Path
        if (this.animConfig) {
            const baseKey = this.animConfig.base;
            if (baseKey) {
                const baseImg = Assets.get(baseKey);

                if (baseImg) {
                    if (this._dirty || !this.renderRect.w) {
                        this._updateRenderRect(baseImg);
                    }
                    // Draw Base
                    this._drawImageAutoSlice(ctx, baseImg, this.renderRect);
                }
            }

            // Overrides (Priority: Smile/Shocked > Talk/Idle)
            if (this.state === 'smile' && this.animConfig.smile) {
                this._drawOverlay(ctx, this.animConfig.smile);
                return;
            }
            if (this.state === 'shocked' && this.animConfig.shocked) {
                this._drawOverlay(ctx, this.animConfig.shocked);
                return;
            }

            // Idle
            if (this.animConfig.idle) {
                this._drawOverlay(ctx, this.animConfig.idle);
            }

            // Talk
            if (this.isTalking && this.currentTalkFrame) {
                this._drawOverlay(ctx, this.currentTalkFrame, this.animConfig.talkOffset);
            }

            // Blink
            if (this.currentBlinkFrame) {
                this._drawOverlay(ctx, this.currentBlinkFrame, this.animConfig.blinkOffset);
            }

            return;
        }

        // B. Legacy Path (Optimization: minimal updates)
        this._drawLegacy(ctx);
    }

    _drawLegacy(ctx) {
        let imgKey = null;
        if (this.isCpu) {
            imgKey = this.data.battleFaceR || ((this.data.face) ? null : null); // Fallback complex
        } else {
            imgKey = this.data.battleFaceL || ((this.data.face) ? null : null);
        }

        const img = imgKey ? Assets.get(imgKey) : null;

        // Use fallback generic calc if no img yet or fallback
        if (!img) {
            if (this.data.face) {
                // Use simple frame draw
                const globalBaseW = BattleConfig.PORTRAIT.baseW || 264;
                const scale = this.config.scale || 1.0;
                let dx = this.config.x;
                let dy = this.config.y;
                const destW = globalBaseW * scale;
                const destH = 280 * scale;
                if (this.config.align === 'right') dx -= destW;
                Assets.drawFrame(ctx, this.data.face, dx, dy, this.isCpu ? 1 : 0, destW, destH);
            }
            return;
        }

        if (this._dirty || !this.renderRect.w) {
            this._updateRenderRect(img);
        }
        this._drawImageAutoSlice(ctx, img, this.renderRect);
    }

    _drawOverlay(ctx, imgKey, offset) {
        const img = Assets.get(imgKey);
        // Only draw if base rect exists and image exists
        if (img && this.renderRect.w > 0) {
            const xo = offset?.x || 0;
            const yo = offset?.y || 0;

            // Temporary offset override for this drawing call
            // We pass a modified rect object or just params?
            // Let's modify the params passed to slice logic, NOT the stored rect.
            const targetX = this.renderRect.x + xo;
            const targetY = this.renderRect.y + yo;

            // Re-use calculation logic? 
            // _updateRenderRect computes isSheet. Here we might need to re-check sheet for the OVERLAY image itself.
            // Overlay might be a sprite sheet too? Usually not, but let's be safe and consistent.

            // Lightweight rect for this call
            const rect = {
                x: targetX,
                y: targetY,
                w: this.renderRect.w,
                h: this.renderRect.h,
                // We must check if THIS image is a sheet, not use the base's flag
                isSheet: undefined
            };

            this._drawImageAutoSlice(ctx, img, rect);
        }
    }

    _drawImageAutoSlice(ctx, img, rect) {
        if (this.data?.singleSprite) {
            ctx.drawImage(img, rect.x, rect.y, rect.w, rect.h);
            return;
        }

        // Determine slice status
        let isSheet = rect.isSheet;
        if (isSheet === undefined) {
            // Check cache for THIS image
            if (!this._sheetCache.has(img)) {
                if (img.width > 0) {
                    const globalBaseW = BattleConfig.PORTRAIT.baseW || 264;
                    this._sheetCache.set(img, (img.width >= globalBaseW * 1.5));
                }
            }
            isSheet = !!this._sheetCache.get(img);
        }

        if (isSheet) {
            const frameIndex = this.isCpu ? 1 : 0;
            const frameWidth = img.width / 2;
            const frameHeight = img.height;
            const sx = frameIndex * frameWidth;
            ctx.drawImage(img, sx, 0, frameWidth, frameHeight, rect.x, rect.y, rect.w, rect.h);
        } else {
            ctx.drawImage(img, rect.x, rect.y, rect.w, rect.h);
        }
    }
}
