<html>

<head>
    <title>Map Editor</title>
    <style>
        body {
            background: #222;
            display: flex;
            flex-direction: row;
            font-family: sans-serif;
            height: 100vh;
            margin: 0;
            overflow: hidden;
        }

        .editor-container {
            flex: 1;
            overflow: auto;
            background: #333;
            position: relative;
            display: flex;
            justify-content: flex-start;
            align-items: flex-start;
            padding: 20px;
        }

        .map-grid {
            position: relative;
            background: #000;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
        }

        .tile {
            position: absolute;
            width: 16px;
            height: 16px;
            /* pointer-events: none; REMOVED to allow simple clicks, but we handle click on map container usually? 
               Actually tile has onclick. Keep it. */
            cursor: pointer;
            image-rendering: pixelated;
            background-repeat: no-repeat;
            z-index: 1;
        }

        .anim-obj {
            position: absolute;
            background-repeat: no-repeat;
            image-rendering: pixelated;
            z-index: 10;
            /* Above tiles */
            border: 1px solid rgba(255, 255, 0, 0.5);
            /* Highlight bounds */
            pointer-events: none;
            /* Let clicks pass to grid? No, we might want to select/delete. */
            cursor: pointer;
        }

        .anim-obj:hover {
            border: 1px solid yellow;
        }

        .collision-overlay {
            position: absolute;
            background: rgba(255, 0, 0, 0.5);
            z-index: 15;
            pointer-events: none;
            cursor: pointer;
            width: 16px;
            height: 16px;
        }


        .trigger-overlay {
            position: absolute;
            background: rgba(0, 100, 255, 0.5);
            z-index: 12;
            pointer-events: none;
            cursor: pointer;
            outline: 1px solid rgba(0, 200, 255, 0.8);
        }

        .tile:hover {
            z-index: 100;
            outline: 1px solid white;
        }

        .tile.empty {
            background: none !important;
        }

        .trigger-overlay {
            pointer-events: auto !important;
            /* Allow clicking the overlay itself */
        }

        .sidebar {
            width: 600px;
            background: #1a1a1a;
            color: #eee;
            padding: 20px;
            display: flex;
            flex-direction: column;
            border-right: 1px solid #444;
            z-index: 200;
            overflow-y: auto;
        }

        .palette {
            display: grid;
            grid-template-columns: repeat(16, 32px);
            background: #000;
            padding: 5px;
            /* max-height removed to show all tiles */
            /* overflow-y removed */
            border: 1px solid #555;
        }

        .palette-tile {
            width: 32px;
            height: 32px;
            margin: 0;
            cursor: pointer;
            border: 2px solid transparent;
            box-sizing: border-box;
            /* background-image set via JS */
            background-size: 512px auto;
            /* Scale up for palette visibility (32px view of 16px tile) -> 16px * 2 = 32px, so total width * 2 */
            background-repeat: no-repeat;
        }

        .palette-tile.selected {
            border: 2px solid cyan;
            z-index: 10;
        }

        .palette-tile:hover {
            border-color: #888;
        }

        .controls {
            margin-top: 20px;
        }

        button {
            padding: 10px;
            width: 100%;
            margin-bottom: 10px;
            background: #444;
            color: white;
            border: none;
            cursor: pointer;
        }

        button:hover {
            background: #555;
        }

        button.active {
            background: #d32f2f;
            font-weight: bold;
        }

        textarea {
            width: 100%;
            height: 100px;
            background: #222;
            color: #aaa;
            border: 1px solid #444;
            margin-top: 10px;
            font-size: 10px;
        }
    </style>
</head>

<body>
    <div class="sidebar">
        <h2>Map Editor</h2>

        <div style="margin-bottom: 10px;">
            <label>Map:
                <select id="map-selector" onchange="changeMap()"
                    style="width: 100px; padding: 5px; background: #333; color: white; border: 1px solid #555;">
                    <option value="cave">Cave</option>
                    <option value="bamboo">Bamboo</option>
                </select>
            </label>
        </div>

        <div class="palette" id="palette"></div>
        <div class="controls">
            <p>Selected Tile: <span id="selected-id">None</span></p>
            <p>Hover: <span id="hover-coords">--,--</span></p>

            <div
                style="margin-bottom: 10px; border-bottom: 1px solid #555; padding-bottom: 10px; display: flex; flex-direction: column; gap: 5px;">
                <label><input type="radio" name="mode" value="tile" checked onchange="setMode('tile')"> 타일 모드
                    (Tile)</label>
                <label><input type="radio" name="mode" value="trigger" onchange="setMode('trigger')"> 트리거 생성 모드
                    (Trigger)</label>
                <label><input type="radio" name="mode" value="collision" onchange="setMode('collision')"> 충돌 판정 모드
                    (Collision)</label>
            </div>

            <!-- Trigger Palette -->
            <div id="trigger-palette"
                style="display:none; margin-bottom: 15px; border: 1px solid #444; padding: 10px; background: #222;">
                <h3 style="margin-top: 0;">Trigger Properties</h3>
                <div style="margin-bottom: 5px;"><label>Title: <input type="text" id="trigger-title" value="New Trigger"
                            style="width:100%"></label></div>
                <div style="margin-bottom: 5px;"><label>Type:
                        <select id="trigger-type" style="width:100%">
                            <option value="menu">Menu</option>
                            <option value="warp">Warp</option>
                        </select>
                    </label></div>
                <div style="margin-bottom: 5px; display: flex; gap: 5px;">
                    <label style="flex:1;">X: <input type="number" id="trigger-x" value="0" style="width:100%"></label>
                    <label style="flex:1;">Y: <input type="number" id="trigger-y" value="0" style="width:100%"></label>
                </div>
                <div style="margin-bottom: 5px; display: flex; gap: 5px;">
                    <label style="flex:1;">W: <input type="number" id="trigger-w" value="1" style="width:100%"></label>
                    <label style="flex:1;">H: <input type="number" id="trigger-h" value="1" style="width:100%"></label>
                </div>
                <div style="margin-bottom: 20px;">
                    <label>Items (JSON):</label>
                    <textarea id="trigger-items"
                        style="height: 60px; font-family: monospace;">[{"text": "Sample", "href": "#"}]</textarea>
                </div>
                <div style="display: flex; gap: 5px; margin-top: 10px;">
                    <button id="btn-place-trigger" onclick="placeTriggerAction()"
                        style="flex: 2; background: #2e7d32;">Create Trigger</button>
                    <button id="btn-update-trigger" onclick="updateTrigger()"
                        style="flex: 2; background: #01579b; display: none;">Update Selected</button>
                    <button id="btn-cancel-trigger" onclick="cancelTriggerEdit()"
                        style="flex: 1; background: #444; display: none;">Cancel</button>
                </div>
                <div id="editing-status" style="font-size: 11px; color: #ffeb3b; margin-top: 5px; display: none;">*
                    Editing existing trigger</div>
                <div style="font-size: 11px; color: #888; margin-top: 5px;">
                    * 영역 크기는 일단 1x1로 생성 후 데이터를 수정하세요.<br>
                    * 그리드를 클릭하여 생성하거나 기존 트리거를 편집합니다.
                </div>
            </div>

            <div style="margin-bottom: 10px; display: flex; gap: 5px;">
                <button id="btn-brush" onclick="setBrush()" style="flex: 1; background: #2e7d32;">Brush</button>
                <button id="btn-eraser" onclick="setEraser()" style="flex: 1; background: #444;">Eraser</button>
            </div>
            <div style="margin-bottom: 20px; display: flex; flex-direction: column; gap: 5px;">
                <button onclick="exportMapData()" style="background: #4527a0;">Export Map Data (data.js)</button>
                <button onclick="exportTriggers()" style="background: #1565c0;">Export Triggers (triggers.js)</button>
            </div>
            <div style="margin-bottom: 10px; display: flex; gap: 5px;">
                <button onclick="changeZoom(0.1)" style="flex: 1;">Zoom +</button>
                <button onclick="changeZoom(-0.1)" style="flex: 1;">Zoom -</button>
                <button onclick="resetZoom()" style="flex: 1;">Reset</button>
            </div>
            <p>Zoom: <span id="zoom-level">100%</span></p>

            <textarea id="output" readonly></textarea>

            <hr style="border-color: #555; margin: 20px 0;">
            <h3>Map Config</h3>
            <div style="margin-bottom: 10px;">
                <label>Width (Tiles): <input type="number" id="map-width" value="40" style="width:50px;"></label>
            </div>
            <div style="margin-bottom: 10px;">
                <label>Height (Tiles): <input type="number" id="map-height" value="30" style="width:50px;"></label>
            </div>

            <div style="margin-bottom: 10px;">
                <label>Anchor:
                    <select id="resize-anchor" style="width: 100px;">
                        <option value="tl" selected>Top-Left</option>
                        <option value="tr">Top-Right</option>
                        <option value="bl">Bottom-Left</option>
                        <option value="br">Bottom-Right</option>
                        <option value="c">Center</option>
                    </select>
                </label>
            </div>
            <button onclick="resizeMap()">Update Size</button>

            <!-- Assets section removed: handled via data.js baseline -->
        </div>
    </div>
    <div class="editor-container">
        <div class="map-grid" id="map"></div>
    </div>

    <!-- External Data -->
    <div id="loading" style="color: white; position: absolute; top: 10px; left: 10px; z-index:9999;">Loading Map...
    </div>
    <script>
        // Parse URL parameter for map name
        const urlParams = new URLSearchParams(window.location.search);
        const mapName = urlParams.get('map') || 'cave'; // Default to cave

        // Set selector value
        const mapSelector = document.getElementById('map-selector');
        if (mapSelector) {
            mapSelector.value = mapName;
        }

        function changeMap() {
            const selectedMap = document.getElementById('map-selector').value;
            window.location.search = `?map=${selectedMap}`;
        }

        // Helper for editor to resolve paths relative to the map folder
        // Only used for DISPLAYing images in the editor DOM.
        // The data in JSON remains relative to the data.js file (e.g. "assets/tile.png")
        function resolveEditorPath(path) {
            if (!path) return '';
            if (path.startsWith('http') || path.startsWith('/')) return path;
            // If path is shared "world/system", it might be referenced as "../../system" in data.js
            // Editor is in "world/", so "../../system" -> "system" ??
            // Let's trace:
            // Editor: world/editor.html
            // Path: ../../system/assets/char.png
            // Target: world/system/assets/char.png
            // Direct link: assets/char.png (if in same folder)
            // But data.js is in world/maps/cave/.
            // ../../system means "up to map", "up to world", then "system".
            // So from Editor (world/system):
            // We want to reach world/system/assets/char.png... that is just "assets/char.png"!
            // BUT, if the path is relative to MAP (assets/tile.png), we need "../maps/cave/assets/tile.png".

            if (path.startsWith('../../system')) {
                // ../../system/assets/char.png -> system/assets/char.png (local to editor)
                // But wait, system/ is being removed?
                // The User said "world/system assets" are moved/unnecessary.
                // If there are legacy paths, we might need to fix them or they are broken.
                // Assuming legacy "../../system" paths might now point to "assets/" if they were moved?
                // For now, let's assume they shouldn't occur or are handled.
                // But let's look at the CHAR path.
                return path.replace('../../system/', '');
            }

            if (path.startsWith('../../char')) {
                return path.replace('../../char', 'char');
            }

            // Assume map-relative path
            return `maps/${mapName}/${path}`;
        }

        const script = document.createElement('script');
        script.src = `maps/${mapName}/data.js`;
        script.onload = () => {
            // Load triggers.js if it exists, but don't fail hard if it doesn't?
            // Actually, for now we assume it exists for this map structure.
            const triggerScript = document.createElement('script');
            triggerScript.src = `maps/${mapName}/triggers.js`;
            triggerScript.onload = () => {
                // startEditor will hide the loading message when ready
                if (typeof startEditor === 'function') startEditor();
            };
            triggerScript.onerror = () => {
                console.warn("No triggers.js found, or failed to load. Continuing...");
                if (typeof startEditor === 'function') startEditor();
            };
            document.body.appendChild(triggerScript);
        };
        script.onerror = () => {
            document.getElementById('loading').innerText = `Error: Map '${mapName}' data not found.`;
        };
        document.body.appendChild(script);
    </script>

    <script>
        // Configuration
        const TILE_SIZE = 16;
        const PALETTE_SCALE = 2; // Show tiles 2x bigger in palette
        let ASSET_PATH = '';
        const EMPTY_TILE = { tx: 1, ty: 0 };

        let mapWidthTiles = 40;
        let mapHeightTiles = 30;
        let mapDataGrid = []; // 2D array [y][x] = {tx, ty}

        let currentMode = 'tile'; // 'tile' or 'anim'
        let selectedAnimType = null;

        let triggers = []; // Array of { x, y, w, h, title, type, items }
        let editingTriggerIndex = -1; // Index of trigger being edited
        let isCollisionMode = false;
        let collisionTiles = new Set(); // Stores "gx,gy" strings

        let selectedTx = 0;
        let selectedTy = 0;
        let tilesetWidth = 0;
        let tilesetHeight = 0;
        let zoomLevel = 1.0;

        // Central Start Function called after scripts load
        function startEditor() {
            if (!window.MAP_DATA) {
                alert("Map data not found!");
                return;
            }

            // 1. Determine Asset Path
            if (window.MAP_DATA.assets && window.MAP_DATA.assets.tileset) {
                ASSET_PATH = resolveEditorPath(window.MAP_DATA.assets.tileset);
            } else {
                ASSET_PATH = resolveEditorPath('assets/cave_tile.png'); // Fallback
            }

            // 2. Load Tileset Image to get dimensions
            const img = new Image();
            img.src = ASSET_PATH;
            img.onload = function () {
                tilesetWidth = img.width;
                tilesetHeight = img.height;
                initEditor(); // Now we have dimensions, build everything

                document.getElementById('loading').style.display = 'none';
            };
            img.onerror = function () {
                alert("Tileset image mismatch or not found at: " + ASSET_PATH + "\nCheck if the path is relative to the maps folder.");
                document.getElementById('loading').innerText = "Failed to load assets.";
            }
        }

        function initEditor() {
            console.log("Initializing Editor Components...");

            // 1. Build Palette
            const cols = Math.floor(tilesetWidth / TILE_SIZE);
            const rows = Math.floor(tilesetHeight / TILE_SIZE);
            const palette = document.getElementById('palette');

            // Adjust background size for palette scaling
            // Original width is tilesetWidth. We want 16px tile to be 32px.
            // So we scale the background by PALETTE_SCALE.
            const bgWidth = tilesetWidth * PALETTE_SCALE;

            // Update CSS rule dynamically for palette scale or just set inline

            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    let d = document.createElement('div');
                    d.className = 'palette-tile';
                    // We need to set background position.
                    // Since background-size is 200% (roughly), position needs to be scaled too?
                    // No, background-position is in pixels related to the element box or percentage.
                    // If we set background-size to specific px, we use specific px for position.
                    d.style.backgroundImage = `url('${ASSET_PATH}')`;
                    d.style.backgroundSize = `${bgWidth}px auto`;
                    d.style.backgroundPosition = `-${x * TILE_SIZE * PALETTE_SCALE}px -${y * TILE_SIZE * PALETTE_SCALE}px`;

                    d.onclick = function () { selectTile(this, x, y); };
                    palette.appendChild(d);
                }
            }

            // 2. Load Map Data
            if (window.MAP_DATA) {
                // Load Assets Config
                if (window.MAP_DATA.assets) {
                    // Resolve path for internal editor usage (Images)
                    ASSET_PATH = resolveEditorPath(window.MAP_DATA.assets.tileset);
                }


                // Load Tiles
                let loadedTiles = [];
                if (Array.isArray(window.MAP_DATA)) {
                    loadedTiles = window.MAP_DATA;
                } else {
                    loadedTiles = window.MAP_DATA.tiles || [];
                }

                triggers = window.MAP_DATA.triggers || [];
                renderTriggers();

                if (window.MAP_DATA.collisions) {
                    window.MAP_DATA.collisions.forEach(c => collisionTiles.add(`${c.x},${c.y}`));
                }
                renderCollisions();

                // Determine Size
                let maxX = 0;
                let maxY = 0;
                loadedTiles.forEach(t => {
                    if (t.gx > maxX) maxX = t.gx;
                    if (t.gy > maxY) maxY = t.gy;
                });
                mapWidthTiles = maxX + 1;
                mapHeightTiles = maxY + 1;

                // Populate Data Grid
                mapDataGrid = new Array(mapHeightTiles).fill(0).map(() => new Array(mapWidthTiles).fill(null));
                loadedTiles.forEach(t => {
                    if (t.gx < mapWidthTiles && t.gy < mapHeightTiles) {
                        mapDataGrid[t.gy][t.gx] = { tx: t.tx, ty: t.ty };
                    }
                });

                // Fill gaps
                for (let y = 0; y < mapHeightTiles; y++) {
                    for (let x = 0; x < mapWidthTiles; x++) {
                        if (!mapDataGrid[y][x]) mapDataGrid[y][x] = { ...EMPTY_TILE };
                    }
                }

            } else {
                console.warn("No MAP_DATA found, starting empty.");
                // Init empty
                mapDataGrid = new Array(mapHeightTiles).fill(0).map(() => new Array(mapWidthTiles).fill(null).map(() => ({ ...EMPTY_TILE })));
            }

            // Set Inputs
            document.getElementById('map-width').value = mapWidthTiles;
            document.getElementById('map-height').value = mapHeightTiles;

            renderMapGrid();
        }

        function resizeMap() {
            const newW = parseInt(document.getElementById('map-width').value);
            const newH = parseInt(document.getElementById('map-height').value);
            const anchor = document.getElementById('resize-anchor').value;

            if (newW === mapWidthTiles && newH === mapHeightTiles) return;

            if (!confirm("Resizing might crop map data. Continue?")) return;

            // Create new grid
            const newGrid = new Array(newH).fill(0).map(() => new Array(newW).fill(null));

            let offX = 0;
            let offY = 0;

            if (anchor === 'tr' || anchor === 'br') offX = newW - mapWidthTiles;
            if (anchor === 'bl' || anchor === 'br') offY = newH - mapHeightTiles;
            if (anchor === 'c') {
                offX = Math.floor((newW - mapWidthTiles) / 2);
                offY = Math.floor((newH - mapHeightTiles) / 2);
            }

            for (let y = 0; y < newH; y++) {
                for (let x = 0; x < newW; x++) {
                    const srcX = x - offX;
                    const srcY = y - offY;

                    if (srcX >= 0 && srcX < mapWidthTiles && srcY >= 0 && srcY < mapHeightTiles) {
                        newGrid[y][x] = mapDataGrid[srcY][srcX];
                    } else {
                        newGrid[y][x] = { ...EMPTY_TILE };
                    }
                }
            }

            mapWidthTiles = newW;
            mapHeightTiles = newH;
            mapDataGrid = newGrid;



            renderMapGrid();
        }

        // Removed updateAssets function: assets are handled via data.js baseline

        function renderMapGrid() {
            const mapContainer = document.getElementById('map');
            mapContainer.innerHTML = '';
            mapContainer.style.width = (mapWidthTiles * TILE_SIZE) + 'px';
            mapContainer.style.height = (mapHeightTiles * TILE_SIZE) + 'px';



            // Render Tiles
            for (let y = 0; y < mapHeightTiles; y++) {
                for (let x = 0; x < mapWidthTiles; x++) {
                    let tileData = mapDataGrid[y][x];
                    let div = document.createElement('div');
                    div.className = 'tile';
                    div.id = `cell_${x}_${y}`;
                    div.style.left = (x * TILE_SIZE) + 'px';
                    div.style.top = (y * TILE_SIZE) + 'px';

                    // Use current ASSET_PATH for background
                    div.style.backgroundImage = `url('${ASSET_PATH}')`;

                    if (tileData.tx === EMPTY_TILE.tx && tileData.ty === EMPTY_TILE.ty) {
                        div.classList.add('empty');
                    } else {
                        div.style.backgroundPosition = `-${tileData.tx * TILE_SIZE}px -${tileData.ty * TILE_SIZE}px`;
                    }

                    div.dataset.tx = tileData.tx;
                    div.dataset.ty = tileData.ty;

                    div.onclick = function () { onGridClick(this, x, y); };
                    div.onmousemove = function () {
                        document.getElementById('hover-coords').innerText = x + "," + y;
                    };
                    mapContainer.appendChild(div);
                }
            }

            // Re-render things that float on top (Triggers, Collisions)
            renderTriggers();
            renderCollisions();
        }

        function selectTile(el, tx, ty) {
            setMode('tile'); // Auto switch
            selectedTx = tx;
            selectedTy = ty;
            updateToolUI();

            // Explicitly highlight this one
            el.classList.add('selected');
        }

        function setMode(mode) {
            currentMode = mode;
            if (mode !== 'trigger' && editingTriggerIndex !== -1) {
                cancelTriggerEdit();
            }
            isCollisionMode = (mode === 'collision');

            document.getElementById('palette').style.display = (mode === 'tile') ? 'block' : 'none';
            document.getElementById('trigger-palette').style.display = (mode === 'trigger') ? 'block' : 'none';

            // UI Update: Ensure radio checked
            document.querySelectorAll('input[name="mode"]').forEach(r => {
                if (r.value === mode) r.checked = true;
            });

            renderCollisions(); // Refresh visibility if needed
            renderTriggers();   // Refresh visibility if needed
        }
        function onGridClick(el, gx, gy) {
            if (isCollisionMode) {
                toggleCollisionAt(gx, gy);
            } else if (currentMode === 'tile') {
                paintTile(el, gx, gy);
            } else if (currentMode === 'trigger') {
                const isEraser = (selectedTx === EMPTY_TILE.tx && selectedTy === EMPTY_TILE.ty);
                if (isEraser) {
                    deleteTriggerAt(gx, gy);
                    if (editingTriggerIndex !== -1) cancelTriggerEdit();
                } else {
                    // Brush mode
                    const existingIndex = triggers.findIndex(t =>
                        gx >= t.x && gx < t.x + (t.w || 1) &&
                        gy >= t.y && gy < t.y + (t.h || 1)
                    );

                    if (existingIndex !== -1) {
                        loadTriggerToUI(existingIndex);
                    } else {
                        placeTrigger(gx, gy);
                    }
                }
            }
        }

        function loadTriggerToUI(index) {
            editingTriggerIndex = index;
            const trig = triggers[index];
            document.getElementById('trigger-title').value = trig.title;
            document.getElementById('trigger-type').value = trig.type || 'menu';
            document.getElementById('trigger-x').value = trig.x;
            document.getElementById('trigger-y').value = trig.y;
            document.getElementById('trigger-w').value = trig.w || 1;
            document.getElementById('trigger-h').value = trig.h || 1;
            document.getElementById('trigger-items').value = JSON.stringify(trig.items || []);

            // UI Update
            document.getElementById('btn-place-trigger').style.display = 'none';
            document.getElementById('btn-update-trigger').style.display = 'block';
            document.getElementById('btn-cancel-trigger').style.display = 'block';
            document.getElementById('editing-status').style.display = 'block';

            renderTriggers();
        }

        function cancelTriggerEdit() {
            editingTriggerIndex = -1;
            document.getElementById('btn-place-trigger').style.display = 'block';
            document.getElementById('btn-update-trigger').style.display = 'none';
            document.getElementById('btn-cancel-trigger').style.display = 'none';
            document.getElementById('editing-status').style.display = 'none';
            renderTriggers();
        }

        function updateTrigger() {
            if (editingTriggerIndex === -1) return;

            const title = document.getElementById('trigger-title').value;
            const type = document.getElementById('trigger-type').value;
            const tx = parseInt(document.getElementById('trigger-x').value);
            const ty = parseInt(document.getElementById('trigger-y').value);
            const tw = parseInt(document.getElementById('trigger-w').value);
            const th = parseInt(document.getElementById('trigger-h').value);

            let items = [];
            try {
                items = JSON.parse(document.getElementById('trigger-items').value);
            } catch (e) {
                alert("Invalid Items JSON!");
                return;
            }

            triggers[editingTriggerIndex].title = title;
            triggers[editingTriggerIndex].type = type;
            triggers[editingTriggerIndex].x = tx;
            triggers[editingTriggerIndex].y = ty;
            triggers[editingTriggerIndex].w = tw;
            triggers[editingTriggerIndex].h = th;
            triggers[editingTriggerIndex].items = items;

            alert("Trigger updated!");
            cancelTriggerEdit();
        }

        function placeTriggerAction() {
            // This is just a helper for the button if someone clicks it manually
            alert("그리드를 클릭하여 새 트리거를 배치하세요.");
        }

        function deleteTriggerAt(gx, gy) {
            const index = triggers.findIndex(t =>
                gx >= t.x && gx < t.x + (t.w || 1) &&
                gy >= t.y && gy < t.y + (t.h || 1)
            );
            if (index !== -1) {
                triggers.splice(index, 1);
                renderTriggers();
            }
        }

        function placeTrigger(gx, gy) {
            const title = document.getElementById('trigger-title').value;
            const type = document.getElementById('trigger-type').value;
            let items = [];
            try {
                items = JSON.parse(document.getElementById('trigger-items').value);
            } catch (e) {
                alert("Invalid Items JSON!");
                return;
            }

            let trigger = {
                title: title,
                type: type,
                x: gx,
                y: gy,
                w: parseInt(document.getElementById('trigger-w').value) || 1,
                h: parseInt(document.getElementById('trigger-h').value) || 1,
                items: items
            };

            triggers.push(trigger);
            renderTriggers();
        }

        function renderTriggers() {
            // Clear existing trigger divs
            document.querySelectorAll('.trigger-overlay').forEach(e => e.remove());

            const mapContainer = document.getElementById('map');
            triggers.forEach((trig, index) => {
                const div = document.createElement('div');
                div.className = 'trigger-overlay';
                if (index === editingTriggerIndex) {
                    div.style.background = 'rgba(255, 235, 59, 0.6)'; // Highlight yellow
                    div.style.outline = '2px solid #ffeb3b';
                    div.style.zIndex = '15';
                }
                div.style.left = (trig.x * TILE_SIZE) + 'px';
                div.style.top = (trig.y * TILE_SIZE) + 'px';
                div.style.width = (trig.w * TILE_SIZE) + 'px';
                div.style.height = (trig.h * TILE_SIZE) + 'px';
                div.innerHTML = `<span style="font-size: 8px; color: white;">${trig.title}</span>`;

                div.onclick = (e) => {
                    e.stopPropagation();
                    const isEraser = (selectedTx === EMPTY_TILE.tx && selectedTy === EMPTY_TILE.ty);
                    if (isEraser) {
                        // Eraser Tool -> Delete immediately
                        triggers.splice(index, 1);
                        if (editingTriggerIndex === index) cancelTriggerEdit();
                        else if (editingTriggerIndex > index) editingTriggerIndex--; // Adjust index
                        renderTriggers();
                    } else if (currentMode === 'trigger') {
                        // Brush Tool + Trigger Mode -> Edit
                        loadTriggerToUI(index);
                    } else {
                        // Other Mode -> Ask to delete (Safety)
                        if (confirm(`Delete this trigger (${trig.title})?`)) {
                            triggers.splice(index, 1);
                            if (editingTriggerIndex === index) cancelTriggerEdit();
                            else if (editingTriggerIndex > index) editingTriggerIndex--;
                            renderTriggers();
                        }
                    }
                };

                mapContainer.appendChild(div);
            });
        }

        // Removed toggleCollisionMode: handled via unified setMode

        function toggleCollisionAt(gx, gy) {
            const key = `${gx},${gy}`;
            if (collisionTiles.has(key)) {
                collisionTiles.delete(key);
            } else {
                collisionTiles.add(key);
            }
            renderCollisions();
        }

        function renderCollisions() {
            // Clear existing
            document.querySelectorAll('.collision-overlay').forEach(e => e.remove());

            if (!isCollisionMode && collisionTiles.size === 0) return;
            // Even if not in mode, we might want to see them? Or only in mode?
            // Let's show them if in mode OR we can just show them always? 
            // Usually editor shows walls always or in a view mode. 
            // For now, show if isCollisionMode is true? 
            // Or maybe always show semi-transparent if they exist?
            // Let's show always for now if the user toggled them on? 
            // Actually, let's just render them. 

            // Wait, the Requirement was "Visual Feedback: Render placed animations on the map editor grid."
            // For collisions: "When Collision Mode is active, render a semi-transparent red overlay"

            if (!isCollisionMode) return;

            const mapContainer = document.getElementById('map');
            collisionTiles.forEach(key => {
                const [gx, gy] = key.split(',').map(Number);
                const div = document.createElement('div');
                div.className = 'collision-overlay';
                div.style.left = (gx * TILE_SIZE) + 'px';
                div.style.top = (gy * TILE_SIZE) + 'px';
                div.onclick = (e) => {
                    e.stopPropagation(); // Pass through to grid? 
                    // No, invalidates click if we catch it. 
                    // But we want to toggle.
                    if (isCollisionMode) toggleCollisionAt(gx, gy);
                };
                mapContainer.appendChild(div);
            });
        }

        // startEditorLoop removed (Animation Mode replaced by Trigger Mode)

        // Removed immediate startEditorLoop call

        function setBrush() {
            // If it was eraser, reset to a valid tile (0,0 or last known?)
            if (selectedTx === EMPTY_TILE.tx && selectedTy === EMPTY_TILE.ty) {
                selectedTx = 0;
                selectedTy = 0;
            }
            updateToolUI();
        }

        function setEraser() {
            selectedTx = EMPTY_TILE.tx;
            selectedTy = EMPTY_TILE.ty;
            if (editingTriggerIndex !== -1) cancelTriggerEdit();
            updateToolUI();
        }

        function updateToolUI() {
            const isEraser = (selectedTx === EMPTY_TILE.tx && selectedTy === EMPTY_TILE.ty);
            const eraserBtn = document.getElementById('btn-eraser');
            const brushBtn = document.getElementById('btn-brush');

            if (isEraser) {
                eraserBtn.style.background = '#c33';
                brushBtn.style.background = '#444';
                document.getElementById('selected-id').innerText = "Eraser";
                document.querySelectorAll('.palette-tile').forEach(t => t.classList.remove('selected'));
            } else {
                eraserBtn.style.background = '#444';
                brushBtn.style.background = '#2e7d32';
                document.getElementById('selected-id').innerText = selectedTx + "," + selectedTy;

                // Highlight corresponding tile in palette if it's visible
                document.querySelectorAll('.palette-tile').forEach(t => t.classList.remove('selected'));
                // Note: We don't force highlight here because we don't have the element reference easily,
                // but selectTile handles it when clicked.
            }
        }

        function changeZoom(delta) {
            zoomLevel += delta;
            if (zoomLevel < 0.1) zoomLevel = 0.1;
            updateZoom();
        }

        function resetZoom() {
            zoomLevel = 1.0;
            updateZoom();
        }

        function updateZoom() {
            const mapGrid = document.getElementById('map');
            // Use transform-origin top-left to zoom naturally from the corner
            mapGrid.style.transformOrigin = "0 0";
            mapGrid.style.transform = `scale(${zoomLevel})`;
            document.getElementById('zoom-level').innerText = Math.round(zoomLevel * 100) + "%";
        }



        function paintTile(el, gx, gy) {
            // Update visual
            if (selectedTx === EMPTY_TILE.tx && selectedTy === EMPTY_TILE.ty) {
                el.classList.add('empty');
                el.style.backgroundPosition = '';
            } else {
                el.classList.remove('empty');
                el.style.backgroundPosition = `-${selectedTx * TILE_SIZE}px -${selectedTy * TILE_SIZE}px`;
            }
            // Update data
            // Update data
            el.dataset.tx = selectedTx;
            el.dataset.ty = selectedTy;
            mapDataGrid[gy][gx] = { tx: selectedTx, ty: selectedTy };
        }

        function exportMapData() {
            let cells = document.querySelectorAll('.tile');
            let data = [];
            cells.forEach(c => {
                let parts = c.id.split('_');
                let gx = parseInt(parts[1]);
                let gy = parseInt(parts[2]);
                let tx = parseInt(c.dataset.tx);
                let ty = parseInt(c.dataset.ty);
                if (tx !== EMPTY_TILE.tx || ty !== EMPTY_TILE.ty) {
                    data.push({ gx, gy, tx, ty });
                }
            });

            const result = {
                assets: (window.MAP_DATA && window.MAP_DATA.assets) ? window.MAP_DATA.assets : {},
                collisions: Array.from(collisionTiles).map(k => {
                    const [x, y] = k.split(',').map(Number);
                    return { x, y };
                }),
                tiles: data
            };

            document.getElementById('output').value = "window.MAP_DATA = " + JSON.stringify(result, null, 2);
            alert(`Map Data exported!\n- Tiles: ${data.length}\n- Collisions: ${collisionTiles.size}`);
        }

        function exportTriggers() {
            const result = {
                triggers: triggers
            };
            // Note: Triggers.js usually appends to window.MAP_DATA.triggers or similar
            // Here we provide the full data for window.MAP_DATA.triggers update
            document.getElementById('output').value = "window.MAP_DATA.triggers = " + JSON.stringify(triggers, null, 2);
            alert(`Triggers exported!\n- Count: ${triggers.length}`);
        }
    </script>
</body>

</html>